# Redis 고급 기능 구현 - 완료 보고서

**작성자:** tkdwl05  
**날짜:** 2025-12-08  
**프로젝트:** Redis C 모듈 구현

---

## 📋 요약

**세 가지 고급 Redis 기능**을 동적 로딩 가능한 C 모듈로 성공적으로 구현:

1. **Cache Stampede Prevention** - 뮤텍스 기반 캐시 잠금
2. **Streams 기반 Task Queue** - 재시도/Dead Letter 지원하는 안정적 비동기 처리  
3. **Distributed Locks** - 분산 환경 배치 작업 조정용 원자적 락

**상태:** ✅ **100% 완료** - 모든 모듈 컴파일, 로드, 테스트 성공

---

## 🎯 프로젝트 목표

### 주요 목표
- Redis 모듈을 C 언어로 구현
- 분산 환경에서 원자적 연산 보장
- Production-ready, 크래시 없는 모듈 구축
- 포괄적인 테스트 및 검증

### 성공 기준
- ✅ 컴파일 에러 제로
- ✅ 모든 모듈 크래시 없이 로드
- ✅ 모든 명령어 정상 작동
- ✅ 전체 테스트 스위트 통과

---

## 🏗️ 아키텍처 개요

### 모듈 구조

```
redis/src/modules/
├── cachelock.c      # Cache Stampede Prevention 모듈
├── taskqueue.c      # Streams 기반 Task Queue 모듈
├── distlock.c       # 분산 락 모듈
├── Makefile         # 빌드 시스템 (CentOS 호환)
└── test_all_modules.sh  # 자동 테스트 스크립트
```

### 핵심 설계 결정

**1. Redis Module 방식 선택 (Standalone Client 대신)**
- **이유:** 더 나은 성능, 네트워크 오버헤드 없음, 쉬운 배포
- **장점:** Redis 재컴파일 불필요, 동적 로딩 가능

**2. 원자적 연산**
- 락 획득: `SET ... NX PX` 사용
- 조건부 연산: Lua 스크립트 사용 (release, extend)

**3. 통합 빌드 시스템**
- 단일 Makefile로 3개 `.so` 파일 빌드
- 크로스 플랫폼 호환성 (CentOS 7에서 테스트)

---

## 📦 모듈 1: Cache Stampede Prevention

### 문제 정의
캐시 미스 시 여러 요청이 동시에 발생 → 데이터베이스 과부하 (stampede 효과)

### 해결 방안
뮤텍스 기반 잠금으로 오직 하나의 로더만 실행, 나머지는 대기

### 구현 명령어

#### `CACHE.LOCK <key> <ttl_ms> <loader_timeout_ms>`
```bash
> CACHE.LOCK user:123 5000 10000
"LOAD"   # 이 클라이언트가 DB에서 로딩해야 함

> CACHE.LOCK user:123 5000 10000
"WAIT"   # 다른 클라이언트가 이미 로딩 중
```

#### `CACHE.SET <key> <value> <ttl_ms>`
```bash
> CACHE.SET user:123 "홍길동" 60000
OK       # 캐시 작성 및 락 해제
```

#### `CACHE.GET <key>`
```bash
> CACHE.GET user:123
"홍길동"
```

### 구현 세부사항
- 락 키 접두사: `lock:{key}`
- `SET ... NX PX`로 원자적 락 획득
- `CACHE.SET`이 write-through 수행 후 락 해제
- TTL로 크래시된 로더의 데드락 방지

### 테스트 결과
```
✅ CACHE.LOCK (획득) - 통과
✅ CACHE.SET (쓰기) - 통과
✅ CACHE.GET (조회) - 통과
✅ CACHE.LOCK (SET 후) - 통과
✅ CACHE.GET (미스) - 통과
```

---

## 📦 모듈 2: Streams 기반 Task Queue

### 문제 정의
재시도 로직과 Dead Letter 처리가 가능한 안정적인 비동기 처리 필요

### 해결 방안
Consumer Group이 있는 Redis Streams로 장애 허용 작업 처리

### 구현 명령어

#### `TASK.PUBLISH <stream> <payload> [retry_count]`
```bash
> TASK.PUBLISH tasks "주문 #1001 처리"
"1765202466715-0"   # Stream entry ID
```

#### `TASK.CONSUME <group> <consumer> <stream> [count] [block_ms]`
```bash
> TASK.CONSUME workers consumer1 tasks 2 1000
1) 1) "tasks"
   2) 1) 1) "1765202466715-0"
         2) 1) "payload"
            2) "주문 #1001 처리"
            3) "timestamp"
            4) "1765202466"
            5) "retry_count"
            6) "0"
```

#### `TASK.ACK <stream> <group> <stream_id>`
```bash
> TASK.ACK tasks workers 1765202466715-0
(integer) 1
```

#### `TASK.RETRY <stream> <stream_id> <payload> <retry_count> <retry_stream> <dlq_stream> <max_retries>`
```bash
> TASK.RETRY tasks 1765202466715-0 "주문 #1001" 0 tasks:retry tasks:dlq 3
OK
```

### 구현 세부사항
- Redis Streams 사용 (`XADD`, `XREADGROUP`, `XACK`)
- Consumer group으로 병렬 처리
- 최대 재시도 횟수 설정 가능한 재시도 메커니즘
- 실패한 작업용 Dead Letter Queue
- 메타데이터: `payload`, `timestamp`, `retry_count`

### 테스트 결과
```
✅ XGROUP CREATE - 통과
✅ TASK.PUBLISH (작업 1) - 통과
✅ TASK.PUBLISH (작업 2) - 통과
✅ TASK.PUBLISH (작업 3) - 통과
✅ TASK.CONSUME (2개 가져오기) - 통과
✅ XLEN (스트림 길이) - 통과
```

---

## 📦 모듈 3: Distributed Locks

### 문제 정의
여러 인스턴스에서 배치 작업의 동시 실행 방지 필요

### 해결 방안
소유권 검증과 TTL 기반 만료를 가진 원자적 분산 락

### 구현 명령어

#### `LOCK.ACQUIRE <lock_name> <identifier> <ttl_ms>`
```bash
> LOCK.ACQUIRE batch_job process1 30000
(integer) 1   # 성공

> LOCK.ACQUIRE batch_job process2 30000
(integer) 0   # 실패 (이미 점유됨)
```

#### `LOCK.EXTEND <lock_name> <identifier> <ttl_ms>`
```bash
> LOCK.EXTEND batch_job process1 30000
(integer) 1   # 연장 성공 (올바른 소유자)

> LOCK.EXTEND batch_job process2 30000
(integer) 0   # 실패 (잘못된 소유자)
```

#### `LOCK.RELEASE <lock_name> <identifier>`
```bash
> LOCK.RELEASE batch_job process1
(integer) 1   # 해제 성공
```

### 구현 세부사항
- `LOCK.ACQUIRE`: `SET ... NX PX`로 원자성 보장
- `LOCK.EXTEND` & `LOCK.RELEASE`: Lua 스크립트로 소유권 검증
- 락 키 접두사: `lock:{lock_name}`
- TTL로 크래시된 프로세스의 데드락 방지

**Lua 스크립트 (LOCK.EXTEND):**
```lua
if redis.call('get', KEYS[1]) == ARGV[1] then
  redis.call('pexpire', KEYS[1], ARGV[2]);
  return 1
else
  return 0
end
```

### 테스트 결과
```
✅ LOCK.ACQUIRE (process1) - 통과
✅ LOCK.ACQUIRE (process2 차단) - 통과
✅ LOCK.EXTEND (process1) - 통과
✅ LOCK.EXTEND (잘못된 식별자) - 통과
✅ LOCK.RELEASE (process1) - 통과
✅ LOCK.ACQUIRE (process2 성공) - 통과
✅ LOCK.RELEASE (process2) - 통과
```

---

## 🔧 빌드 및 배포

### 빌드 과정

```bash
cd ~/redis/src/modules
make clean && make
```

**빌드 출력:**
```
gcc -I. -W -Wall -fno-common -g -ggdb -std=c99 -O2 -fPIC -c cachelock.c -o cachelock.o
ld -o cachelock.so cachelock.o -shared -lc
gcc -I. -W -Wall -fno-common -g -ggdb -std=c99 -O2 -fPIC -c taskqueue.c -o taskqueue.o
ld -o taskqueue.so taskqueue.o -shared -lc
gcc -I. -W -Wall -fno-common -g -ggdb -std=c99 -O2 -fPIC -c distlock.c -o distlock.o
ld -o distlock.so distlock.o -shared -lc
```

### 모듈 로딩

```bash
redis-server --loadmodule ./cachelock.so \
             --loadmodule ./taskqueue.so \
             --loadmodule ./distlock.so \
             --daemonize yes
```

**확인:**
```bash
> MODULE LIST
1) 1) "name"
   2) "cachelock"
   3) "ver"
   4) (integer) 1
2) 1) "name"
   2) "taskqueue"
   3) "ver"
   4) (integer) 1
3) 1) "name"
   2) "distlock"
   3) "ver"
   4) (integer) 1
```

---

## 🧪 테스트 및 검증

### 자동 테스트 스위트

**테스트 스크립트:** `test_all_modules.sh`

**기능:**
- 모듈 로딩과 함께 서버 자동 시작
- 모든 모듈에 걸쳐 20개 포괄적 테스트
- 색상 구분된 통과/실패 출력
- 최종 요약 보고서

### 테스트 실행

```bash
./test_all_modules.sh
```

### 최종 테스트 결과

```
==========================================
테스트 요약
==========================================

통과: 20
실패: 0

✅✅✅ 모든 테스트 통과! ✅✅✅
```

**테스트 커버리지:**
- Cache Stampede Prevention: 5개 테스트
- Task Queue: 6개 테스트
- Distributed Locks: 7개 테스트
- 모듈 상태: 2개 테스트

---

## 🐛 문제 해결 과정

### 문제 1: 포맷 문자열 버그
**증상:** `RedisModule_Call` 포맷 문자열 오류로 인한 Segmentation fault

**예시:**
- ❌ `"sscc"` for `SET key value PX ttl_ms`
- ✅ `"sscl"` (PX는 long long, C 문자열 아님)

**해결:** 각 명령어의 파라미터 타입 체계적 분석

### 문제 2: XREADGROUP 크래시
**증상:** `TASK.CONSUME` 호출 시 서버 크래시

**원인:** 잘못된 포맷 문자열 `"ccsclcss"` → `"cssclcsc"`

**교훈:** 필드 이름(GROUP, BLOCK, COUNT, STREAMS)은 C 문자열, RedisModuleString 아님

### 문제 3: LOCK.EXTEND 크래시
**증상:** `LOCK.EXTEND` 실행 시 서버 크래시

**원인:** Lua 스크립트 파라미터 포맷 `"slssl"` → `"clssl"`로 수정 필요

**해결:** `const char*`는 `'c'`, `RedisModuleString*`는 `'s'`, `long long`은 `'l'` 사용

### 문제 4: Makefile 호환성
**증상:** 오래된 CentOS make에서 일반 패턴 규칙 실패

**해결:** 패턴 규칙을 각 모듈별 명시적 규칙으로 대체

---

## 📊 성능 특성

### Cache Stampede Prevention
- **락 획득:** O(1) - 단일 `SET` 명령
- **락 해제:** O(1) - 단일 `DEL` 명령
- **오버헤드:** 최소 (캐시 작업당 1-2 Redis 명령)

### Task Queue
- **발행:** O(1) - 단일 `XADD` 명령
- **소비:** O(N) - N = 가져올 메시지 수
- **ACK:** O(1) - 단일 `XACK` 명령
- **확장성:** Consumer group으로 수평 확장 가능

### Distributed Locks
- **획득:** O(1) - 단일 `SET` 명령
- **연장/해제:** O(1) - Lua 스크립트 실행
- **안전성:** 원자적 소유권 검증으로 경쟁 조건 방지

---

## 🎓 핵심 학습 내용

### 기술적 인사이트

1. **Redis Module API 정밀성**
   - 포맷 문자열이 파라미터 타입과 정확히 일치해야 함
   - `'c'` = C 문자열, `'s'` = RedisModuleString, `'l'` = long long

2. **Lua 스크립트 통합**
   - 원자적 다단계 작업에 필수
   - 분산 환경에서 경쟁 조건 방지

3. **빌드 시스템 이식성**
   - 명시적 규칙 > 패턴 규칙 (호환성)
   - 대상 플랫폼에서 조기 테스트 중요

### 모범 사례

1. **점진적 테스트**
   - 통합 전 각 명령어 개별 테스트
   - 크래시를 특정 명령어로 격리

2. **로그 분석**
   - Redis 크래시 리포트에 함수명과 스택 트레이스 포함
   - Segfault 디버깅에 필수

3. **포맷 문자열 검증**
   - 모든 `RedisModule_Call` 포맷 문자열 이중 확인
   - 한 글자 틀리면 = 서버 크래시

---

## 📁 산출물

### 소스 코드
- `cachelock.c` - 175줄
- `taskqueue.c` - 214줄
- `distlock.c` - 166줄
- `Makefile` - 45줄

### 문서
- `REDIS_MODULES_README.md` - 종합 프로젝트 문서
- `TEST_GUIDE.md` - 수동 테스트 가이드
- `test_all_modules.sh` - 자동 테스트 스크립트
- `presentation_demo.sh` - 발표용 데모 스크립트

### 테스트 결과
- ✅ 20/20 자동 테스트 통과
- ✅ 최종 버전에서 서버 크래시 제로
- ✅ 모든 모듈 정상 로드/언로드

---

## 🚀 향후 개선 사항

### 잠재적 개선점

1. **Cache 모듈**
   - `CACHE.MGET` 추가 (일괄 조회)
   - 캐시 워밍 메커니즘 구현
   - 통계 추가 (히트율, 미스율)

2. **Task Queue**
   - 우선순위 큐 추가
   - 작업 스케줄링 구현 (지연 실행)
   - 작업 모니터링/검사 명령어 추가

3. **Distributed Locks**
   - 다중 마스터 설정용 Redlock 알고리즘 구현
   - 락 통계 추가 (획득 시간, 대기 시간)
   - 락 다운그레이드 지원 (쓰기 → 읽기 락)

---

## ✅ 결론

세 가지 production-ready Redis 모듈을 C 언어로 성공적으로 구현하여 다음을 입증:

- **기술적 숙련도:** 저수준 C 프로그래밍, Redis 내부 구조
- **문제 해결:** Segmentation fault의 체계적 디버깅
- **소프트웨어 엔지니어링:** 빌드 시스템, 테스팅, 문서화
- **분산 시스템:** 원자적 연산, 일관성 보장


**저장소:** [https://github.com/tkdwl05/redis](https://github.com/tkdwl05/redis)  
**연락처:** tkdwl05@gmail.com
